# java基础知识

## 1-1 语言概述

* 面向对象的最重要的特性是支持继承、封装和多态

* 过程式语言和面向对象的语言各有其优势，过程式语言更加灵活，面向对象语言更加强调抽象和封装

  

### 与c++对比

内存回收靠垃圾回收期，因此不需要一个函数如c++析构函数那样来做垃圾回收工作。 

Java和C++都是静态类型的面向对象编程语言。

java和c++都有三个特征：封装、继承、多态。

java用引用，c++用指针。



## 1-3 基本程序结构

### 基本变量类型

#### 默认

整数型的默认是int，带小数的默认是double

#### 字节数

char型两个字节。iso8859-1编码，1个字符一个字节。gbk一个中文字符两个字节。utf8一个中文三个字节。

int型占四个字节

#### 转换

byte short char int long float double

1     2    2    4   8    4     8

左到右自动转换（long到float不用强转，因为float表示的范围确实比long表示的范围大，虽然它只占4个字节，而long占8个字节）



### string类

* String str1 = "aaa"; 是在常量池中获取对象

* String str2 = new String("aaa") ; 一共会创建两个字符串对象一个在堆中，一个在常量池中（前提是常量池中还没有 "aaa" 字符串对象）。

```java
String s1 = new String("AAA");
    String s2 = s1.intern();
    String s3 = "AAA";
    System.out.println(s2);//AAA
    System.out.println(s1 == s2);//false，因为一个是堆内存中的String对象一个是常量池中的String对象，
    System.out.println(s2 == s3);//true， s1,s2指向常量池中的”AAA“
```



### 二进制的负数

1. 正数的原码、反码、补码都相同； 

2. 负数的原码：最高位为1，其余位为真值的绝对值； 
3. 负数的反码：在原码的基础上，符号位不变，其余位按位取反； 
4. 负数的补码：在原码的基础上，符号位不变，其余位取反，最后加1；也就是在反码的基础上加1。

```
-125=-（64+32+16+8+4+1）
原码   11111101
反码   10000010
补码   10000011
```

原码=（补码-1）【然后除符号位其他取反】

补码=原码除符号位取反+1



## 2-2 抽象类与接口

### 抽象类

1. 含有abstract方法的类必须定义为abstract class，abstract class类中的方法不必是抽象的。

2. abstract class类中定义抽象方法必须在具体(Concrete)子类中实现，所以不能有抽象构造方法或抽象静态方法
3. 子类没有实现抽象父类中的所有抽象方法，那么子类也必须定义为abstract类型

### 接口

接口（interface）可以说成是**抽象类的一种特例**，接口中的所有方法都必须是抽象的。

接口中的**方法定义默认为public  abstract类型，接口中的成员变量类型默认为public static final**。



### 区别

1. 抽象类可以有构造方法，接口中不能有构造方法。 

2. 抽象类中可以有普通成员变量，接口中没有普通成员变量 

3. 抽象类中可以包含非抽象的普通方法，接口中的所有方法必须都是抽象的，不能有非抽象的普通方法。 

4. 抽象类中的抽象方法的访问类型可以是public，protected和（默认类型,虽然 
    eclipse下不报错，但应该也不行），但接口中的抽象方法只能是public类型的，并且默认即为public abstract类型。 

5. 抽象类中可以包含静态方法，接口中不能包含静态方法 

6. 抽象类和接口中都可以包含静态成员变量，抽象类中的静态成员变量的访问类型可以任意，但接口中定义的变量只能是public static  final类型，并且默认即为public static final类型。 

7. 一个类可以实现多个接口，但只能继承一个抽象类。

   

## 2-3 函数

### 序列化

- ```
  使用transient修饰的变量不会被序列化
  ```

- ```
  对象序列化的所属类需要实现Serializable接口
  ```



## 3-3 jvm

**运行时常量池**是方法区的一部分。Class 文件中除了有类的版本、字段、方法、接口等描述信息外，还有常量池信息（用于存放编译期生成的各种字面量和符号引用）

ps: a="1", "1"就是字面量。



## 3-4 垃圾回收

对象空间被收集前执行finalize方法。

finalize和c++的析构函数（做垃圾回收工作）不是一回事。

一旦成为垃圾，不会立刻被回收的。



## 3-5 子类与父类

Super subToSuper=new Sub();//静态类型是Super，实际类型是Sub



## 3-6 重写与重载

**静态方法不存在重写**，重写只对可见的实例方法。静态方法只有隐藏。

com.example.javaBasic.overwrite.StaticMethodNoOverwriteSub

**重载**是根据形参的**静态类型**确定调用的方法版本。

com.example.javaBasic.overload.UseStaticType



## 3-7 算术

### 除法

15 / 2 = 7

7 / 2 = 3

3 / 2 = 1



## 3-8 初始化

### 正常顺序

com.example.javaBasic.init.NormalOrderSuper

com.example.javaBasic.init.NormalOrderSub

父静态（静态变量实例和静态代码块的顺序由编写先后决定） -> 子静态 ->  子main -> 父非静态-> 父构造函数 -> 子非静态 -> 子构造函数



即使静态变量实例在后，静态代码块依然能用静态变量实例（xxx.xx），因为加载时静态的都放在了方法区，但是未实例，所以输出会为null。如果静态变量实例在线就不null。



### 静态的只执行一次

com.example.javaBasic.init.StaticOnlyOnce

静态变量实例和静态代码块的顺序有编写先后决定。只要静态代码块输出静态变量实例就知道是不是跟书写顺序有关了。

因为静态参数和代码块是按编写顺序执行。如果自己先静态实例化自己，静态代码块依然要最外层来执行，相当于最外层锁定了，要到静态参数实例完了再执行静态代码块。



## 3-9 集合

### map

* threadlocalmap使用开放定址法解决hash冲突，量小
* hashmap使用链地址法解决hash冲突，因为量大



## 3-10 设计模式

四种线程安全单例模式实现：

1. 饿汉模式（其实枚举类也是不给外界实例化机会，变相其实参数都是public static final。枚举与类的根本区别就在构造方法私有。）
2. 懒汉模式，synchronized getInstance
3. 在getInstance里面double-check
4. 内部静态工厂类